================================================================================
DETAILED UNTESTED FUNCTIONS - TARGET LIST FOR TEST DEVELOPMENT
================================================================================

FORMAT:
  Module: full/path/to/module.py (LOC)
  Function/Class: name(signature) [Line count] {Criticality}
  Description of business logic

================================================================================
SERVICES - UNTESTED (1/6)
================================================================================

Module: services/store_service.py (59 lines)
Criticality: MEDIUM

CLASS StoreService:

  Method: load_store(path: Path) → dict[str, Any] [10 lines] {MEDIUM}
    Business Logic:
      - File existence check
      - JSON deserialization with error handling (JSONDecodeError, OSError)
      - Empty dict fallback on error
      - UTF-8 encoding
    Testing Gaps:
      ○ Valid JSON file loading
      ○ Missing file → empty dict
      ○ Invalid JSON → empty dict with warning logged
      ○ OSError during read → empty dict with warning

  Method: save_store(path: Path, data: dict[str, Any]) → None [12 lines] {MEDIUM}
    Business Logic:
      - Parent directory creation (mkdir parents=True)
      - JSON serialization with UTF-8 encoding
      - Indented JSON output
      - OSError handling
    Testing Gaps:
      ○ Creates parent directories if missing
      ○ Valid JSON written with indent=2
      ○ UTF-8 encoding preserved
      ○ OSError during write → warning logged
      ○ Data integrity after save/load cycle

FUNCTION: get_store_service() → StoreService [8 lines] {MEDIUM}
  Business Logic:
    - Singleton pattern with global mutable state
    - Lazy initialization
  Testing Gaps:
    ○ Returns same instance on multiple calls
    ○ Initial None state
    ○ Thread safety (if used in multi-threaded context)

================================================================================
UTILITIES - UNTESTED (13 files, ~1,900 LOC)
================================================================================

═══════════════════════════════════════════════════════════════════════════════
TIER 1: CRITICAL BUSINESS LOGIC (4 modules, ~1,350 LOC)
═══════════════════════════════════════════════════════════════════════════════

Module: utils/card_data.py (283 lines)
Criticality: CRITICAL

FUNCTION: load_card_manager(data_dir: Path | str = Path("data"), 
                            force: bool = False) → CardDataManager [19 lines] {CRITICAL}
  Business Logic:
    - Directory path handling (Path | str)
    - CardDataManager instantiation and initialization
    - ensure_latest() call with force parameter
  Testing Gaps:
    ○ Default path used when not specified
    ○ Custom path respected
    ○ Force flag passed through correctly
    ○ Returns ready-to-use manager

CLASS CardDataManager:

  Method: __init__(data_dir: Path | str = Path("data")) [7 lines] {CRITICAL}
    Business Logic:
      - Directory creation
      - Path resolution
      - Index/meta path setup
      - Private field initialization
    Testing Gaps:
      ○ Creates data_dir if missing
      ○ Resolves string paths to Path objects
      ○ Sets up correct index and meta paths

  Method: ensure_latest(force: bool = False) → None [44 lines] {CRITICAL}
    Business Logic:
      - HTTP dependency check (curl_cffi import)
      - Remote metadata fetching via HEAD request
      - Cache freshness detection (ETag, Last-Modified, Content-Length)
      - ZIP file download and extraction
      - JSON parsing from ZIP
      - Card index building
      - Fallback to stale cache on network failure
      - Logging of refresh operations
    Testing Gaps:
      ○ HTTP available → fetches remote meta
      ○ HTTP unavailable with no cache → raises RuntimeError
      ○ HTTP unavailable with cache → uses cache
      ○ Force=true → always downloads
      ○ Cache fresh (ETag matches) → no download
      ○ Cache stale (ETag different) → downloads
      ○ Network error with cache → uses stale cache with warning
      ○ Network error without cache → raises RuntimeError

  Method: search_cards(query: str = "", format_filter: str | None = None,
                      type_filter: str | None = None,
                      color_identity: list[str] | None = None,
                      limit: int | None = None) → list[dict[str, Any]] [38 lines] {CRITICAL}
    Business Logic:
      - Query normalization (strip, lowercase)
      - Format/type filter normalization
      - Color identity uppercase conversion
      - Multi-field search (name, type_line, oracle_text)
      - Legality filtering
      - Type line substring matching
      - Color identity all-must-match logic
      - Result limiting
    Testing Gaps:
      ○ Empty query → returns all cards (unless filters applied)
      ○ Query in name → matches
      ○ Query in type_line → matches
      ○ Query in oracle_text → matches
      ○ Format filter → only Legal cards in that format
      ○ Type filter → substring match in type_line
      ○ Color identity → all colors must be present
      ○ Limit applied correctly
      ○ Case insensitivity
      ○ Multiple filters combined

  Method: get_card(name: str) → dict[str, Any] | None [3 lines] {CRITICAL}
    Business Logic:
      - Name lookup in cards_by_name dict
      - Case-insensitive lookup
    Testing Gaps:
      ○ Card found → returns dict
      ○ Card not found → returns None
      ○ Case insensitive matching

  Method: available_formats() → list[str] [8 lines] {CRITICAL}
    Business Logic:
      - Iterate all cards
      - Collect all formats with "Legal" status
      - Remove duplicates while preserving order
      - Sort alphabetically
    Testing Gaps:
      ○ Returns list of legal formats
      ○ No duplicates
      ○ Alphabetically sorted
      ○ Only "Legal" status included (not Banned, Restricted)

  Method: _require_cards() → None [3 lines] {CRITICAL}
    Business Logic:
      - Validation that cards are loaded
      - Raises RuntimeError if not loaded
    Testing Gaps:
      ○ Raises when _cards is None
      ○ Doesn't raise when _cards is populated

  Method: _fetch_remote_meta() → dict[str, Any] | None [2 lines] {CRITICAL}
    Delegates to _fetch_dataset_headers()

  Method: _fetch_dataset_headers() → dict[str, Any] | None [16 lines] {CRITICAL}
    Business Logic:
      - HTTP HEAD request to MTGJSON API
      - ETag extraction and stripping quotes
      - Last-Modified header extraction
      - Content-Length header extraction
      - Error handling and logging
    Testing Gaps:
      ○ Valid headers → returns meta dict
      ○ Missing headers → returns None or partial dict
      ○ Network error → returns None with warning
      ○ ETag quotes stripped
      ○ All headers normalized to lowercase

  Method: _download_and_rebuild(remote_meta: dict[str, Any] | None) → None [20 lines] {CRITICAL}
    Business Logic:
      - HTTP GET request for ZIP file
      - SHA512 hash calculation
      - ZIP file extraction to memory
      - JSON parsing from AtomicCards.json in ZIP
      - Card index building
      - Metadata merging (remote + computed)
      - File writes with UTF-8 encoding
    Testing Gaps:
      ○ Downloads ZIP from correct URL
      ○ Extracts AtomicCards.json from ZIP
      ○ Calculates SHA512 hash
      ○ Parses JSON correctly
      ○ Builds index from parsed data
      ○ Saves index and meta files
      ○ Preserves remote metadata
      ○ Adds computed metadata (sha512)

  Method: _load_index() → None [5 lines] {CRITICAL}
    Business Logic:
      - Load index from file
      - Parse JSON
      - Populate _cards and _cards_by_name
      - Raise RuntimeError if missing/invalid
    Testing Gaps:
      ○ Loads valid index file
      ○ Raises when file missing
      ○ Raises when JSON invalid
      ○ Populates _cards and _cards_by_name correctly

  Method: _load_json(path: Path) → dict[str, Any] | None [8 lines] {CRITICAL}
    Business Logic:
      - File existence check
      - JSON parsing with error handling
      - Warning logging on JSONDecodeError
    Testing Gaps:
      ○ Valid JSON → returns dict
      ○ Missing file → returns None
      ○ Invalid JSON → returns None with warning

  Method: _build_index(atomic_cards: dict) → dict[str, Any] [24 lines] {CRITICAL}
    Business Logic:
      - Iterate atomic card variations
      - Skip tokens
      - Handle split cards (faceName)
      - Deduplicate by lowercase name
      - Simplify printing data
      - Merge legalities across printings
      - Sort cards alphabetically
      - Build reverse lookup (by lowercase name)
    Testing Gaps:
      ○ Tokens skipped
      ○ Split cards handled correctly
      ○ Deduplication by name works
      ○ Legalities merged correctly (all Legal printings)
      ○ Alphabetical sorting
      ○ Reverse lookup dict created
      ○ Handles empty input
      ○ Handles malformed data

  Method: _simplify_printing(printing: dict, face_name: str) → dict [22 lines] {CRITICAL}
    Business Logic:
      - Extract relevant fields from printing
      - Type conversions (manaValue to float)
      - Create normalized dict
      - Handle missing fields gracefully
    Testing Gaps:
      ○ All fields extracted correctly
      ○ manaValue converted to float
      ○ Handles missing fields (empty lists/None)
      ○ Colors and color_identity arrays preserved
      ○ Legalities dict created with lowercase keys

  Method: _merge_legalities(base: dict | None, 
                           incoming: dict | None) → dict [5 lines] {CRITICAL}
    Business Logic:
      - Merge two legality dicts
      - Only keep "Legal" entries
      - Prefer either source if not in other
    Testing Gaps:
      ○ Both None → empty dict
      ○ Base only → returns Legal entries from base
      ○ Incoming only → returns Legal entries from incoming
      ○ Both present → union of Legal entries
      ○ Non-Legal entries excluded
      ○ Duplicate formats taken once

─────────────────────────────────────────────────────────────────────────────

Module: utils/card_images.py (707 lines)
Criticality: CRITICAL

CLASS CardImageCache:

  Method: __init__(cache_dir: Path = IMAGE_CACHE_DIR, 
                   db_path: Path = IMAGE_DB_PATH) [6 lines] {CRITICAL}
    Business Logic:
      - Cache directory resolution
      - Database path resolution
      - Directory creation
      - Path roots computation
      - SQLite database initialization
    Testing Gaps:
      ○ Creates cache directories
      ○ Resolves relative paths
      ○ Initializes SQLite schema
      ○ Builds path roots for resolution

  Method: _ensure_directories() → None [4 lines] {CRITICAL}
    Business Logic:
      - Create cache base directory
      - Create subdirectory for each image size
    Testing Gaps:
      ○ Creates all size directories
      ○ Doesn't fail if already exist

  Method: _build_path_roots() → list[Path] [17 lines] {CRITICAL}
    Business Logic:
      - Collect candidate paths (cwd, cache_dir, parent, grandparent)
      - Resolve to absolute paths
      - Deduplicate
      - Return in order
    Testing Gaps:
      ○ Returns list of resolved paths
      ○ No duplicates
      ○ Includes expected directories
      ○ Handles edge cases (no grandparent)

  Method: _init_database() → None [13 lines] {CRITICAL}
    Business Logic:
      - Create SQLite schema if not exists
      - Create card_images table with proper columns
      - Set uuid as PRIMARY KEY
    Testing Gaps:
      ○ Creates table on first call
      ○ Doesn't fail on subsequent calls (IF NOT EXISTS)
      ○ Schema correct (uuid, name, size, path, downloaded_at, etc.)

  Method: save_image_metadata(uuid: str, name: str, size: str, 
                             path: Path, downloaded_at: str | None = None) → None [10 lines] {CRITICAL}
    Business Logic:
      - Insert or replace image metadata in database
      - Handle datetime conversion
    Testing Gaps:
      ○ Saves metadata to database
      ○ Handles duplicate UUIDs (replaces)
      ○ Stores correct path
      ○ Stores timestamp

  Method: get_image_path(uuid: str, size: str) → Path | None [12 lines] {CRITICAL}
    Business Logic:
      - Query database for image path
      - Resolve path from multiple roots if relative
      - Return absolute path or None
    Testing Gaps:
      ○ Returns path when found
      ○ Returns None when not found
      ○ Resolves relative paths
      ○ Handles multiple path roots

  Method: get_downloaded_count() → int [4 lines] {CRITICAL}
    Business Logic:
      - Count rows in database
    Testing Gaps:
      ○ Returns correct count
      ○ Returns 0 when empty

  Method: delete_image(uuid: str, size: str) → bool [8 lines] {CRITICAL}
    Business Logic:
      - Get image path
      - Delete file from filesystem
      - Delete record from database
      - Handle OSError on file deletion
    Testing Gaps:
      ○ Deletes file when it exists
      ○ Deletes database record
      ○ Returns True on success
      ○ Handles missing file gracefully (OSError)

CLASS BulkImageDownloader:

  Method: __init__(cache: CardImageCache, max_workers: int = 10) [5 lines] {CRITICAL}
    Business Logic:
      - Store cache reference
      - Store max_workers for ThreadPoolExecutor
    Testing Gaps:
      ○ Initializes state correctly

  Method: download_images(cards: list[dict], 
                         progress_callback: Callable | None = None) → None [25 lines] {CRITICAL}
    Business Logic:
      - Create ThreadPoolExecutor with max_workers
      - Submit download tasks for each card/size variant
      - Wait for completion
      - Call progress callback
      - Handle exceptions
    Testing Gaps:
      ○ Downloads multiple images concurrently
      ○ Calls progress callback with updates
      ○ Handles download errors without stopping
      ○ Completes all tasks

  Method: _download_single(uuid: str, name: str, 
                          image_url: str, size: str) → bool [15 lines] {CRITICAL}
    Business Logic:
      - HTTP GET request with timeout
      - Save file to cache
      - Update database
      - Handle network errors
    Testing Gaps:
      ○ Downloads image from URL
      ○ Writes to correct size directory
      ○ Saves metadata in database
      ○ Returns False on network error
      ○ Returns True on success

MODULE-LEVEL FUNCTIONS:

FUNCTION: _load_printing_index_payload() → dict[str, Any] | None [8 lines] {CRITICAL}
  Business Logic:
    - Check if printing index cache exists
    - Load and parse JSON
    - Return None if invalid/missing
  Testing Gaps:
    ○ Loads valid JSON
    ○ Returns None when missing
    ○ Returns None when invalid

FUNCTION: ensure_printing_index_cache(force: bool = False) → dict[str, Any] [18 lines] {CRITICAL}
  Business Logic:
    - Check cache freshness
    - Download if stale or force=True
    - Return index data
  Testing Gaps:
    ○ Returns cached data when fresh
    ○ Downloads when stale
    ○ Downloads when force=True
    ○ Caches result

FUNCTION: get_cache() → CardImageCache [3 lines] {CRITICAL}
  Business Logic:
    - Singleton pattern
  Testing Gaps:
    ○ Returns same instance
    ○ Initializes on first call

FUNCTION: get_card_image(card_name: str, size: str = "normal") → Path | None [12 lines] {CRITICAL}
  Business Logic:
    - Look up card in printing index
    - Query cache for image path
    - Return path or None
  Testing Gaps:
    ○ Returns path when image cached
    ○ Returns None when not cached
    ○ Returns None when card not found

FUNCTION: download_bulk_images(limit: int = None, 
                              progress_callback: Callable | None = None) → None [12 lines] {CRITICAL}
  Business Logic:
    - Load printing index
    - Create downloader
    - Filter cards (limit)
    - Start concurrent downloads
  Testing Gaps:
    ○ Downloads all cards by default
    ○ Respects limit parameter
    ○ Calls progress callback

FUNCTION: get_cache_stats() → dict[str, Any] [6 lines] {CRITICAL}
  Business Logic:
    - Count downloaded images
    - Count expected images
    - Calculate hit rate
  Testing Gaps:
    ○ Returns correct counts
    ○ Calculates percentages

─────────────────────────────────────────────────────────────────────────────

Module: navigators/mtggoldfish.py (338 lines)
Criticality: CRITICAL

FUNCTION: _load_cached_archetypes(mtg_format: str, 
                                 max_age: int = METAGAME_CACHE_TTL_SECONDS) [14 lines] {CRITICAL}
  Business Logic:
    - Check cache file exists
    - Load and parse JSON
    - Extract format entry
    - Check timestamp is within max_age
    - Return items or None
  Testing Gaps:
    ○ Returns None when cache missing
    ○ Returns None when format missing
    ○ Returns None when cache too old
    ○ Returns items when fresh

FUNCTION: _save_cached_archetypes(mtg_format: str, items: list[dict]) [13 lines] {CRITICAL}
  Business Logic:
    - Load existing cache (or empty dict)
    - Update entry with timestamp
    - Write back to file
  Testing Gaps:
    ○ Creates new cache if missing
    ○ Updates existing cache
    ○ Timestamps recorded
    ○ File written with correct format

FUNCTION: get_archetypes(mtg_format: str, cache_ttl: int = ..., 
                        allow_stale: bool = True) → list [40 lines] {CRITICAL}
  Business Logic:
    - Check fresh cache first
    - If not available, fetch from MTGGoldfish
    - Parse HTML (BeautifulSoup)
    - Extract archetypes from specific selector
    - Save to cache
    - On network error: return stale cache if allow_stale=True
    - Raise on network error if allow_stale=False
  Testing Gaps:
    ○ Returns cached data when fresh
    ○ Fetches from MTGGoldfish when not cached
    ○ Parses HTML correctly
    ○ Returns fallback stale cache on network error
    ○ Raises when network error and no fallback
    ○ Saves fetched data to cache
    ○ Handles missing container element

FUNCTION: get_archetype_decks(archetype: str) → list [32 lines] {CRITICAL}
  Business Logic:
    - Fetch archetype page from MTGGoldfish
    - Parse HTML for deck table
    - Extract deck info (date, player, event, result)
    - Return list of deck dicts
    - Handle missing table
  Testing Gaps:
    ○ Fetches correct URL
    ○ Parses table correctly
    ○ Extracts all required fields
    ○ Returns empty list on error
    ○ Skips header row

FUNCTION: get_archetype_stats(mtg_format: str) → dict [55 lines] {CRITICAL}
  Business Logic:
    - Check for cache files (including legacy locations)
    - Handle legacy file migration
    - If cache fresh (< 1 day), return it
    - Otherwise, fetch archetypes and decks
    - For each archetype, get last 7 days of results
    - Count decks by date
    - Save to cache
    - Return stats
  Testing Gaps:
    ○ Returns cached data when fresh
    ○ Fetches new data when stale
    ○ Migrates legacy cache files
    ○ Filters decks by date correctly
    ○ Counts results per date correctly
    ○ Handles missing/empty archetype data
    ○ Saves stats with timestamp

FUNCTION: get_daily_decks(mtg_format: str) → dict [51 lines] {CRITICAL}
  Business Logic:
    - Fetch metagame page from MTGGoldfish
    - Parse for tournament sections (h4 + table)
    - Extract deck info (name, player, placement)
    - Group by date
    - Return structured deck data
  Testing Gaps:
    ○ Parses multiple tournament sections
    ○ Extracts date from h4
    ○ Extracts tournament type
    ○ Detects if placement should be shown
    ○ Extracts deck number from link href
    ○ Groups by date correctly

FUNCTION: _resolve_deck_cache_path() → tuple[Path, str | None] [11 lines] {CRITICAL}
  Business Logic:
    - Check for cache in multiple legacy locations
    - Return path and legacy_source indicator
    - Used for migration purposes
  Testing Gaps:
    ○ Returns correct path when found
    ○ Indicates legacy source
    ○ Checks all legacy locations in order

FUNCTION: _load_deck_cache() → tuple [10 lines] {CRITICAL}
  Business Logic:
    - Resolve cache path
    - Load and parse JSON
    - Return (cache, path, legacy_source)
  Testing Gaps:
    ○ Returns empty cache when missing
    ○ Loads JSON correctly
    ○ Handles invalid JSON

FUNCTION: _persist_deck_cache(deck_cache: dict, cache_path: Path, 
                             legacy_source: str | None) → None [13 lines] {CRITICAL}
  Business Logic:
    - Write cache to standard location
    - Delete legacy cache if migrating
  Testing Gaps:
    ○ Writes to correct location
    ○ Handles directory creation
    ○ Deletes legacy files on migration

FUNCTION: fetch_deck_text(deck_num: str) → str [19 lines] {CRITICAL}
  Business Logic:
    - Check cache first
    - If not cached, fetch from MTGGoldfish
    - Parse JavaScript with regex to extract deck data
    - URL decode the extracted data
    - Save to cache
    - Return deck text
  Testing Gaps:
    ○ Returns cached deck when available
    ○ Fetches from MTGGoldfish when not cached
    ○ Regex correctly extracts encoded deck
    ○ URL decoding works correctly
    ○ Raises ValueError on parse failure
    ○ Saves to cache after fetch

FUNCTION: download_deck(deck_num: str) → None [14 lines] {CRITICAL}
  Business Logic:
    - Fetch deck text
    - Write to CURR_DECK_FILE
    - Clean up legacy deck files
  Testing Gaps:
    ○ Creates directory if missing
    ○ Writes deck text to file
    ○ Removes legacy files
    ○ Handles file write errors

═══════════════════════════════════════════════════════════════════════════════
TIER 2: HIGH COMPLEXITY BUSINESS LOGIC (4 modules, ~650 LOC)
═══════════════════════════════════════════════════════════════════════════════

Module: navigators/mtgo_decklists.py (194 lines)
Criticality: HIGH

FUNCTION: _load_cache() → dict[str, Any] [8 lines] {HIGH}
  Business Logic:
    - Load cache JSON from file
    - Return empty dict if missing/invalid
  Testing Gaps:
    ○ Loads valid cache
    ○ Returns empty dict when missing
    ○ Handles invalid JSON

FUNCTION: _save_cache(cache: dict) → None [7 lines] {HIGH}
  Business Logic:
    - Create parent directory
    - Write cache JSON with indentation
  Testing Gaps:
    ○ Creates directories
    ○ Writes valid JSON
    ○ Preserves formatting

FUNCTION: _fetch_html(url: str) → str [4 lines] {HIGH}
  Business Logic:
    - HTTP GET request with chrome impersonation
    - Return HTML text
  Testing Gaps:
    ○ Fetches correct URL
    ○ Returns HTML
    ○ Raises on network error

FUNCTION: _classify_event(title: str) → tuple[str | None, str | None] [18 lines] {HIGH}
  Business Logic:
    - Extract format from first word
    - Detect event type from title keywords:
      * "league" → league
      * "challenge" → challenge
      * "preliminary" → preliminary
      * "super qualifier" → super_qualifier
      * "qualifier" → qualifier
      * default → other
  Testing Gaps:
    ○ Extracts format correctly
    ○ Detects all event types
    ○ Case insensitive matching
    ○ Handles None/empty title
    ○ Returns correct tuple

FUNCTION: fetch_decklist_index(year: int, month: int) → list[dict] [37 lines] {HIGH}
  Business Logic:
    - Check cache for year-month key
    - If not cached, fetch HTML from MTGO
    - Parse HTML with BeautifulSoup
    - Extract li.decklists-item elements
    - For each entry:
      * Extract link href (full URL)
      * Extract title
      * Extract format hint from icon class
      * Extract publish date
      * Classify event
    - Save to cache
    - Return entries
  Testing Gaps:
    ○ Returns cached entries when available
    ○ Fetches and parses HTML correctly
    ○ Extracts all fields
    ○ Constructs full URLs
    ○ Classifies events
    ○ Saves to cache
    ○ Handles missing elements gracefully

FUNCTION: _parse_deck_event(html: str) → dict[str, Any] [5 lines] {HIGH}
  Business Logic:
    - Extract JavaScript object from HTML using regex
    - Parse as JSON
    - Return dict
  Testing Gaps:
    ○ Extracts JSON correctly
    ○ Parses JSON
    ○ Raises ValueError on failure

FUNCTION: fetch_deck_event(url: str) → dict[str, Any] [11 lines] {HIGH}
  Business Logic:
    - Check cache for URL
    - If not cached, fetch HTML
    - Parse deck event JSON
    - Save to cache
    - Return event dict
  Testing Gaps:
    ○ Returns cached event
    ○ Fetches and parses new events
    ○ Saves to cache
    ○ Raises on parse failure

FUNCTION: iter_deck_events(entries: Iterable) → Iterable [7 lines] {HIGH}
  Business Logic:
    - Iterate entries
    - For each, fetch deck event
    - Yield (entry, event) tuple
    - Handle and log exceptions
  Testing Gaps:
    ○ Yields correct tuples
    ○ Handles fetch errors
    ○ Continues on error

FUNCTION: fetch_recent_event_history(limit: int = 10) → list[dict] [38 lines] {HIGH}
  Business Logic:
    - Get current month/year
    - Fetch decklist index for that month
    - Iterate deck events
    - For each deck, extract:
      * player/pilot
      * standing/finish/result
      * record/points
      * mtgoId/identifier/deckId
    - Transform to match history format
    - Group by event
    - Limit to N events
  Testing Gaps:
    ○ Gets current month correctly
    ○ Fetches index
    ○ Transforms deck data correctly
    ○ Maps field variations
    ○ Groups by event
    ○ Applies limit
    ○ Handles missing fields

─────────────────────────────────────────────────────────────────────────────

Module: utils/mana_icon_factory.py (436 lines)
Criticality: HIGH

CLASS ManaIconFactory:

  Method: __init__() [4 lines] {HIGH}
    Business Logic:
      - Initialize bitmap cache (dict)
      - Load CSS resources and glyphs
      - Ensure font is loaded
    Testing Gaps:
      ○ Cache initialized empty
      ○ CSS loaded correctly
      ○ Font loaded if available

  Method: render(parent: wx.Window, mana_cost: str) → wx.Window [17 lines] {HIGH}
    Business Logic:
      - Create panel widget
      - Tokenize mana cost string
      - Create horizontal sizer
      - For each token, create StaticBitmap
      - Add spacing between icons
      - Set min size based on count
      - Return panel
    Testing Gaps:
      ○ Creates panel with correct layout
      ○ Handles empty cost
      ○ Spaces icons correctly
      ○ Sets appropriate size
      ○ Returns wx.Window

  Method: bitmap_for_symbol(symbol: str) → wx.Bitmap [4 lines] {HIGH}
    Business Logic:
      - Strip whitespace
      - Remove braces if present
      - Get bitmap via _get_bitmap
    Testing Gaps:
      ○ Strips leading/trailing spaces
      ○ Removes braces
      ○ Returns bitmap

  Method: _tokenize(cost: str) → list[str] [10 lines] {HIGH}
    Business Logic:
      - Split on braces
      - Strip whitespace from parts
      - Filter empty strings
      - Return list of tokens
    Testing Gaps:
      ○ Correctly tokenizes "{W}{U}{B}"
      ○ Handles spaces
      ○ Handles empty strings
      ○ Handles malformed input

  Method: _get_bitmap(symbol: str) → wx.Bitmap [57 lines] {VERY HIGH}
    Business Logic:
      - Check bitmap cache
      - Normalize symbol
      - Detect hybrid components
      - Create memory DC with bitmap
      - Draw shadow circle
      - Draw main circle (filled or split for hybrid)
      - Draw glyph/text on circle
      - For hybrid: draw overlay on second color
      - Apply blur and scale down
      - Cache result
    Testing Gaps:
      ○ Returns cached bitmap on repeat calls
      ○ Creates correct sized bitmap
      ○ Draws shadow
      ○ Fills circle with correct color
      ○ Draws glyph if found
      ○ Handles hybrid colors
      ○ Applies scaling
      ○ Caches results

  Method: _build_render_font(scale: int) → wx.Font [9 lines] {HIGH}
    Business Logic:
      - If font loaded, use "Mana" font
      - Otherwise use Swiss font with bold
      - Scale size by parameter
    Testing Gaps:
      ○ Returns correct font
      ○ Uses Mana font when loaded
      ○ Falls back to Swiss
      ○ Scales size correctly

  Method: _draw_component(...) → None [24 lines] {HIGH}
    Business Logic:
      - Get color for key
      - Draw filled circle with outline
      - Draw glyph text centered in circle
    Testing Gaps:
      ○ Draws with correct color
      ○ Draws with/without outline
      ○ Centers text correctly

  Method: _draw_hybrid_circle(...) → tuple [7 lines] {HIGH}
    Business Logic:
      - Draw circle with first color
      - Draw diagonal line dividing colors
      - Return second color
    Testing Gaps:
      ○ Draws circle
      ○ Draws diagonal line
      ○ Returns correct color

  Method: _draw_hybrid_glyph(...) → None [13 lines] {HIGH}
    Business Logic:
      - For each component, draw scaled glyph
      - Offset positions for hybrid layout
      - Restore original font
    Testing Gaps:
      ○ Draws both glyphs
      ○ Positions correctly
      ○ Scales correctly

  Method: _apply_hybrid_overlay(...) → wx.Bitmap [14 lines] {HIGH}
    Business Logic:
      - Convert bitmap to image
      - For each pixel, if within radius and on correct side:
        * Set to second color
    Testing Gaps:
      ○ Applies overlay correctly
      ○ Only within radius
      ○ Only on correct half

  Method: _scaled_font(font: wx.Font, factor: float) → wx.Font [12 lines] {HIGH}
    Business Logic:
      - Calculate new size (min 6)
      - Create new font with scaled size
      - Preserve other properties
    Testing Gaps:
      ○ Scales size correctly
      ○ Minimum size enforced
      ○ Other properties preserved

  Method: _glyph_fallback(key: str | None) → str [18 lines] {HIGH}
    Business Logic:
      - Direct lookup
      - Compact lookup (remove slashes)
      - Tail lookup (last character only)
      - Default to uppercase key
    Testing Gaps:
      ○ Direct lookup works
      ○ Fallback to compact (e.g., "w/u" → "wu")
      ○ Fallback to tail (e.g., "2/w" → "w")
      ○ Final default to uppercase

  Method: _color_for_key(key: str | None) → tuple [16 lines] {HIGH}
    Business Logic:
      - Direct color lookup
      - Numeric/X/Y/Z → colorless
      - Dashed colors → first part
      - First character lookup
      - Numbered hybrid (2/X) → second character
      - Fallback to multicolor
    Testing Gaps:
      ○ Direct colors work (w, u, b, r, g, c)
      ○ Numerics → colorless
      ○ Dashes handled
      ○ Hybrids detected and colored

  Method: _normalize_symbol(symbol: str) → str | None [18 lines] {HIGH}
    Business Logic:
      - Strip and lowercase
      - Replace ½ → half
      - Handle slashes in tokens
      - Check aliases (∞ → infinity, etc.)
    Testing Gaps:
      ○ Normalizes all symbol variations
      ○ Applies aliases
      ○ Handles slashes
      ○ Handles special characters

  Method: _hybrid_components(key: str | None) → list[str] | None [12 lines] {HIGH}
    Business Logic:
      - Check if two-color hybrid (e.g., "wu", "br")
      - Check if two-hybrid (e.g., "2w", "2u")
      - Return [color1, color2] or None
    Testing Gaps:
      ○ Detects two-color hybrids
      ○ Detects two-hybrids (generic)
      ○ Returns None for non-hybrids

  Method: _ensure_font_loaded() → None [9 lines] {HIGH}
    Business Logic:
      - Check if already loaded
      - Try to load TTF font from assets
      - Set _FONT_LOADED flag if successful
      - Log on failure
    Testing Gaps:
      ○ Loads font if file exists
      ○ Sets flag on success
      ○ Handles missing file
      ○ Handles exceptions

  Method: _load_css_resources() → tuple [32 lines] {HIGH}
    Business Logic:
      - Load CSS file
      - Parse color variables (--ms-mana-*)
      - Parse glyph mappings (.ms-* classes)
      - Extract hex colors and convert to RGB
      - Map selectors to content unicode characters
      - Apply fallback colors
    Testing Gaps:
      ○ Parses CSS correctly
      ○ Extracts colors
      ○ Extracts glyphs
      ○ Handles missing CSS
      ○ Applies fallbacks

MODULE-LEVEL FUNCTIONS:

FUNCTION: normalize_mana_query(raw: str) → str [48 lines] {HIGH}
  Business Logic:
    - Normalize mana input string
    - Handle multiple input formats (spaced, comma-separated, etc.)
    - Convert to canonical {X}{Y} format
  Testing Gaps:
    ○ Converts single letters to braced format
    ○ Handles numbers
    ○ Handles separators
    ○ Preserves already-braced input
    ○ Handles special characters

FUNCTION: tokenize_mana_symbols(cost: str) → list[str] [8 lines] {HIGH}
  Business Logic:
    - Split on braces
    - Strip whitespace
    - Uppercase
    - Return list
  Testing Gaps:
    ○ Tokenizes correctly
    ○ Handles empty input
    ○ Uppercase conversion

FUNCTION: type_global_mana_symbol(token: str) → None [6 lines] {HIGH}
  Business Logic:
    - Normalize query
    - Simulate typing via wxUIActionSimulator
  Testing Gaps:
    ○ Normalizes input
    ○ Simulates keystrokes

─────────────────────────────────────────────────────────────────────────────

Module: utils/mtgo_bridge.py (147 lines)
Criticality: HIGH

FUNCTION: _bridge_available(bridge_path: str | None = None) → tuple [4 lines] {HIGH}
  Business Logic:
    - Validate bridge path exists
    - Return (bool, message)
  Testing Gaps:
    ○ Returns (True, path) when exists
    ○ Returns (False, error) when missing

FUNCTION: ensure_runtime_ready(bridge_path: str | None = None) → tuple [2 lines] {HIGH}
  Delegates to runtime_status()

FUNCTION: runtime_status(bridge_path: str | None = None) → tuple [4 lines] {HIGH}
  Business Logic:
    - Check if bridge available
    - Return (bool, None) or (bool, message)
  Testing Gaps:
    ○ Returns (True, None) when ready
    ○ Returns (False, message) when not

FUNCTION: get_collection_snapshot(bridge_path: str | None = None, 
                                 timeout: float | None = None) → Mapping [9 lines] {HIGH}
  Business Logic:
    - Run bridge "collection" command
    - Validate payload structure
    - Extract collection dict
    - Return dict or empty dict on error
  Testing Gaps:
    ○ Extracts collection from payload
    ○ Validates structure
    ○ Returns empty dict on error
    ○ Handles various payload formats

FUNCTION: get_match_history(...) → Mapping [9 lines] {HIGH}
  Business Logic:
    - Run bridge "history" command
    - Extract and validate history dict
  Testing Gaps:
    ○ Similar to get_collection_snapshot

FUNCTION: get_trade_snapshot(...) → Mapping [10 lines] {HIGH}
  Business Logic:
    - Fetch trade via mtgo_bridge_client
    - Extract and validate trade Mapping
  Testing Gaps:
    ○ Extracts trade from payload
    ○ Validates structure

FUNCTION: fetch_collection_async(...) [3 lines] {HIGH}
  Delegates to mtgo_bridge_client

FUNCTION: fetch_history_async(...) [2 lines] {HIGH}
  Delegates to mtgo_bridge_client

FUNCTION: start_watch(...) [3 lines] {HIGH}
  Delegates to mtgo_bridge_client

FUNCTION: accept_pending_trades(*_args, **_kwargs) → dict [32 lines] {HIGH}
  Business Logic:
    - Call mtgo_bridge_client.accept_trade()
    - Catch BridgeCommandError
    - Extract response fields (accepted, requested, error, timestamp)
    - Return structured response dict
  Testing Gaps:
    ○ Success case → returns accepted/requested bools
    ○ Error case → catches exception, returns error message
    ○ Malformed response → returns error
    ○ Extracts timestamp correctly
    ○ Returns empty error string on success

FUNCTION: list_decks(*_args, **_kwargs) → list [2 lines] {MEDIUM}
  Returns empty list (legacy API)

FUNCTION: get_full_collection(...) → Mapping [2 lines] {MEDIUM}
  Backward compatible alias for get_collection_snapshot()

─────────────────────────────────────────────────────────────────────────────

Module: utils/metagame.py (67 lines)
Criticality: HIGH

FUNCTION: get_latest_deck(player: str, option: str) → str [67 lines] {HIGH}
  Business Logic:
    - Strip player name
    - Fetch MTGGoldfish player page
    - Parse HTML table
    - If no table found and player starts with '0':
      * Retry with 'O' instead of '0' (OCR error correction)
    - For each table row:
      * Check if 8 columns (tds)
      * Check if format matches option (case-insensitive)
      * Extract deck archetype from column 3
    - Return archetype or "Unknown"
  Testing Gaps:
    ○ Fetches correct URL
    ○ Parses table correctly
    ○ Format matching (case-insensitive)
    ○ Returns correct archetype
    ○ Handles OCR 0/O correction
    ○ Returns "Unknown" when no results
    ○ Handles network errors
    ○ Handles missing table

═══════════════════════════════════════════════════════════════════════════════
TIER 3: CONFIGURATION / CONSTANTS (Low Priority)
═══════════════════════════════════════════════════════════════════════════════

Module: utils/paths.py (38 lines) - Initialization code
Module: utils/game_constants.py (47 lines) - Static lists
Module: utils/service_config.py (21 lines) - Constants
Module: utils/stylize.py (60 lines) - Styling helpers
Module: utils/ui_constants.py (26 lines) - Constants
Module: utils/paths_constants.py (7 lines) - Path constants

These are low complexity, minimal business logic. Skip for now.

─────────────────────────────────────────────────────────────────────────────

Module: utils/ui_helpers.py (71 lines) - PARTIALLY TESTED (test_helpers.py)

Should check which functions are already covered and which need additional tests.

================================================================================
